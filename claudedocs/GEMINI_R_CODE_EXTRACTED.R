# ==============================================================================
# GEMINI-GENERATED R CODE (Extracted from Gemini Conversation)
# Source: untitled text 18.md
# Date: 2025-11-23
# Status: UNTESTED - Generated by AI, not validated against real data
# ==============================================================================

# ------------------------------------------------------------------------------
# PART 1: HELPER FUNCTIONS (ODK Specifics)
# ------------------------------------------------------------------------------

# Function to split ODK select_multiple columns into binary 1/0 columns
process_select_multiple <- function(df, col_name, prefix) {
  # Get unique values from the column to know what options exist (optional dynamic approach)
  # or simply rely on known choices. Here we use a generic split approach.

  if(!col_name %in% names(df)) return(df)

  df %>%
    mutate(temp_col = str_split(!!sym(col_name), " ")) %>%
    unnest(temp_col) %>%
    mutate(value = 1) %>%
    pivot_wider(
      names_from = temp_col,
      values_from = value,
      values_fill = 0,
      names_prefix = paste0(prefix, "_")
    ) %>%
    group_by(uuid) %>% # Assuming 'uuid' or '_uuid' is your unique ID
    summarise(across(starts_with(prefix), max), .groups = "drop") %>%
    right_join(df, by = "uuid")
}

# Function to recode Likert scales (adjust text based on your choices.csv)
recode_likert <- function(x) {
  case_when(
    x %in% c("strongly_agree", "very_safe", "very_clean", "5") ~ 5,
    x %in% c("agree", "safe", "clean", "4") ~ 4,
    x %in% c("neutral", "3") ~ 3,
    x %in% c("disagree", "unsafe", "dirty", "2") ~ 2,
    x %in% c("strongly_disagree", "very_unsafe", "very_dirty", "1") ~ 1,
    TRUE ~ NA_real_
  )
}

# ------------------------------------------------------------------------------
# PART 2: FULL PROCESSING SCRIPT
# ------------------------------------------------------------------------------

# Install packages if not already installed
if (!require("pacman")) install.packages("pacman")
pacman::p_load(tidyverse, janitor, stringr, readr)

# Load Data (Adjust paths if necessary)
hh_raw <- read_csv("household_survey_LONG_BIEN_2024_ALL_merged.csv", show_col_types = FALSE)
ven_raw <- read_csv("vendor_survey_LONG_BIEN_2024_ALL_merged.csv", show_col_types = FALSE)

# Clean column names (converts 'foodgroups/cereals' to 'foodgroups_cereals')
hh_data <- hh_raw %>% clean_names()
ven_data <- ven_raw %>% clean_names()

# ==============================================================================
# HOUSEHOLD SURVEY PROCESSING
# ==============================================================================

hh_processed <- hh_data %>%
  # --- A. CLEANING & FORMATTING ---
  mutate(
    # Ensure numeric columns are actually numeric (remove commas/dots if text)
    across(starts_with("time"), ~parse_number(as.character(.))),
    foodexpenditure = parse_number(as.character(foodexpenditure)),
    income = parse_number(as.character(income)),

    # Standardize Food Expenditure to MONTHLY
    food_exp_monthly = case_when(
      foodexp_timeunit == "day" ~ foodexpenditure * 30,
      foodexp_timeunit == "week" ~ foodexpenditure * 4.3,
      foodexp_timeunit == "month" ~ foodexpenditure,
      TRUE ~ NA_real_
    )
  ) %>%

  # --- B. DIETARY DIVERSITY SCORE (DDS) ---
  # Construct: OUT-01 & OUT-03
  # Logic: Sum of binary 'foodgroups_001_x' columns (1 if consumed, 0 if not)
  # Note: janitor::clean_names() changes '/' to '_'
  mutate(
    # Nutrient-Dense Groups
    consumed_veg_leafy = as.integer(foodgroups_001_veg_darkgreenleafy),
    consumed_veg_vita  = as.integer(foodgroups_001_veg_vitamina),
    consumed_veg_other = as.integer(foodgroups_001_veg_other),
    consumed_fruit_vit = as.integer(foodgroups_001_fruits_vitamina),
    consumed_fruit_oth = as.integer(foodgroups_001_fruits_other),
    consumed_meat      = as.integer(foodgroups_001_meat_flesh),
    consumed_organ     = as.integer(foodgroups_001_meat_organ),
    consumed_fish      = as.integer(foodgroups_001_fish_seafood),
    consumed_eggs      = as.integer(foodgroups_001_eggs),
    consumed_dairy     = as.integer(foodgroups_001_milk),
    consumed_legumes   = as.integer(foodgroups_001_legumes_nuts_seeds),

    # Processed/Energy-Dense Groups
    consumed_sweets    = as.integer(foodgroups_001_sweets),
    consumed_oils      = as.integer(foodgroups_001_oils_fats),
    consumed_soda      = as.integer(foodgroups_001_spices_cond_bev), # Check label if this includes soda

    # Calculate Total DDS (Count of groups)
    DDS_score = rowSums(select(., starts_with("consumed_")), na.rm = TRUE),

    # Calculate % Nutrient Dense
    pct_nutrient_dense = rowSums(select(., consumed_veg_leafy, consumed_veg_vita,
                                        consumed_fruit_vit, consumed_fish,
                                        consumed_legumes, consumed_eggs), na.rm = TRUE) / DDS_score
  ) %>%

  # --- C. ACCESSIBILITY (TIME) ---
  # Construct: PER-01 & PER-02
  mutate(
    # Recode NAs in time to a high number or keep NA?
    # For now, we calculate "Close Access" (<5 mins) flags for key outlets
    access_supermarket_close = if_else(time <= 5, 1, 0, missing = 0),     # Small Supermarket
    access_market_close      = if_else(time_002 <= 5, 1, 0, missing = 0), # Wet Market
    access_street_close      = if_else(time_003 <= 5, 1, 0, missing = 0)  # Street Vendor
  ) %>%

  # --- D. RESILIENCE (SHOCKS - TYPHOON YAGI) ---
  # Construct: EMG-04
  mutate(
    # Did they stockpile? (Check if column 'typhoon_prepare_stockpiling' exists)
    shock_stockpiled = if_else(typhoon_prepare_stockpiling == 1, 1, 0, missing = 0),
    shock_reduced_spend = if_else(typhoon_prepare_saving_cash == 1, 1, 0, missing = 0),

    # Coping Strategy Index (Simple count of strategies)
    coping_count = rowSums(select(., starts_with("typhoon_cope_")), na.rm = TRUE)
  ) %>%

  # --- E. SOCIAL FORCES ---
  # Construct: EMG-01
  mutate(
    # Social Food Network: Do they Give OR Receive food?
    social_network_active = if_else(foodsharing_activity_give == 1 |
                                    foodsharing_activity_receive == 1, 1, 0, missing = 0)
  )

# ==============================================================================
# VENDOR SURVEY PROCESSING
# ==============================================================================

ven_processed <- ven_data %>%
  # --- A. AVAILABILITY CLASSIFICATION ---
  # Construct: EXT-01
  mutate(
    # Define "Fresh" vs "Processed" inventory
    sells_fresh = if_else(
      foodgroups_veg_darkgreenleafy == 1 | foodgroups_meat_flesh == 1 |
      foodgroups_fish_seafood == 1 | foodgroups_fruits_vitamina == 1,
      1, 0, missing = 0
    ),

    sells_processed_only = if_else(
      sells_fresh == 0 & (foodgroups_sweets == 1 | foodgroups_spices_cond_bev == 1),
      1, 0, missing = 0
    )
  ) %>%

  # --- B. RESILIENCE (RECOVERY) ---
  # Construct: EMG-05
  mutate(
    # Recode Likert/Categorical impact to binary "High Impact"
    yagi_severe_damage = if_else(str_detect(typhoon_damages, "yes"), 1, 0, missing = 0)
  )

# ==============================================================================
# AGGREGATION & EXPORT
# ==============================================================================

# Aggregate Vendor Environment by Neighborhood
env_metrics <- ven_processed %>%
  group_by(neighborhood) %>%
  summarise(
    env_vendor_density = n(),
    env_pct_selling_fresh = mean(sells_fresh, na.rm = TRUE),
    env_pct_yagi_damage = mean(yagi_severe_damage, na.rm = TRUE)
  )

# Join Environment Metrics to Household Data
final_dataset <- hh_processed %>%
  left_join(env_metrics, by = "neighborhood")

# View and Save
print(glimpse(final_dataset))
write_csv(final_dataset, "LONG_BIEN_2024_PROCESSED_FINAL.csv")

cat("\nProcessing Complete. File saved as 'LONG_BIEN_2024_PROCESSED_FINAL.csv'\n")
